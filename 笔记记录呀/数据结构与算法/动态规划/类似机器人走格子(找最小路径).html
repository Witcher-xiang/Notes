<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*
    * 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，
    * 使得路径上的数字总和为最小。
        说明：每次只能向下或者向右移动一步。

        举例：
        输入:
        arr = [
          [1,3,1],
          [1,5,1],
          [4,2,1]
        ]
        输出: 7
        解释: 因为路径 1→3→1→1→1 的总和最小。
    * */
    function fn(arr) {
        /*定义这个二维数组的含义
        * 走到当前位置路径的和的最小值
        * */
        let resultArr = [];
        /*
        * 求出他的状态转换方程
        * f(m,n) = Math.min(fn(m-1,n),fn(m,n-1))+arr[m,n]
        * */

        /*我们来定义一下他的初始值*/
        arr.forEach(item=>{ //添加数组
            resultArr.push([])
        });
        let tempArr = arr[0],  //开始设置初始值
             count01 =0,count02 =0;
        /*设置第一行的*/
        resultArr[0] = tempArr.map((item,index)=>{
            count01 =item+count01;
            return count01
        });
        /*设置第一列的*/
        arr.forEach((item,index)=>{
            count02 = item[0]+count02;
            resultArr[index][0] = count02
        })
        console.log(resultArr);

        /*把整张表整出来*/
        for (let i=1;i<arr.length;i++){
            for (let j=1;j<arr[i].length;j++){
                resultArr[i][j] = Math.min(resultArr[i-1][j],resultArr[i][j-1])+arr[i][j]
            }
        }
        console.log(resultArr)
        console.log()
        let rowLength = arr.length-1
        let columLength = arr[rowLength].length-1
        console.log(columLength)
        return resultArr[rowLength][columLength]
    }
    const  arr = [
        [1,3,1],
        [1,5,1],
        [4,2,1]
    ]
    console.log(fn(arr))
</script>
</html>
