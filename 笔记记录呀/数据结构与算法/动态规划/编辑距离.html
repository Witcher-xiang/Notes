<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*
    * 编辑距离
    *
    * LeetCode 72号问题
    *
    * 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

        你可以对一个单词进行如下三种操作：

        插入一个字符 删除一个字符 替换一个字符

        示例：
        输入: word1 = "horse", word2 = "ros"
        输出: 3
        解释:
        horse -> rorse (将 'h' 替换为 'r')
        rorse -> rose (删除 'r')
        rose -> ros (删除 'e')
        解答

        还是老样子，按照上面三个步骤来，并且我这里可以告诉你，
        * 90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。
    * */
    function fn(word01,word02) {
        /*一、还是定义一个二维数组,寻找其含义*/
        /*
        * 我去这尼玛怎么找兄弟
        *
        * 由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。
        * 那我们就定义 dp[i] [j]的含义为：
        * 当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，
        * 将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]。
        * */
        let resultArr = [];
        for (let key in word02){
            resultArr.push([])
        }

        /*
        * 找出关系数组元素之间的关系式
        *
        * 接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，
        * 但是，不管多难找，大部分情况下，
        *
        * dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。
        * 因为我们的目标就是，**从规模小的，通过一些操作，推导出规模大的。对于这道题，
        * 我们可以对 word1 进行三种操作
        * */
        

        /*
        *一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，
        * 显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）
        *
        * 二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，
        * 而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下
        * （注意字符串与字符的区别）：。
        * (1)修改操作dp[i][j] = dp[i-1][j-1] + 1
        * (2)删除操作dp[i][j] = dp[i-1][j] + 1
        * (3)添加操作dp[i][j] = dp[i][j-1] +1 //为撒要j-1 相当于？word2变短了？
        * dp[i][j] = Math.min(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j])+1
        * */
    }
</script>
</html>
