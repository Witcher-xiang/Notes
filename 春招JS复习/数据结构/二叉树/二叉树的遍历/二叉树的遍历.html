<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*先序遍历*/
    let arr = []
    function fronSearach(node) {
        if (node){
            arr.push(node.val)
            fronSearach(node.left)
            fronSearach(node.right)
        }
    }
    /*这个是我自己想的可能有问题 还是去看iPad上的*/
    function frontSearch(node) {
        if (!node) return null;
        let arr = [];
        let stack = [];
        while (node){
            arr.push(node.val);
            if (node.left){
                stack.push(node.right);
                node = node.left
            } else {
                let tempNode = stack.pop()
                node = tempNode;
            }
        }
    }

    /*中序遍历*/
    let arrIn = [];
    function inOrder(node) {
        if (node){
            inOrder(node.left);
            arrIn.push(node.val);
            inOrder(node.right);
        }
    }
    /*改进版本*/
    function recurBet(root) {
        let arr =[];
        let fn = (root)=>{
            if (root){
                fn(root.left);
                arr.push(root);
                fn(root.right);
            }
        };
        fn(root);
        return arr
    }

    /*非递归*/
    function inOrder01(node) {
        if (!node) return [];
        let stack = [],arr = [];
        stack.push(node);
        while (stack.length){
            let tempNode;
            if (node.right) stack.push(node.right);
            if (node.left)
                stack.push(node.left);
            else
                {
                    tempNode = stack.pop();
                    arr.push(tempNode.val)
                }
        }
    }
    /*改进版本*/
    function unrecurBet(root) {
        if(root == null) return [];
        let stack =[],arr = [];
        let p = root;
        while (p || stack.length){
            while (p){
                stack.push(p);
                p = p.left;
            }
            let temp = stack.pop();
            arr.push(temp.val);
            p = temp.right
        }
        return arr
    }

    /*
    * 后序遍历
    * 这个非递归很难 多去理解理解
    * */
    function behindOrder(root) {
        if (!root) return [];
        let arr = [] , stack = [];
        let visited = new Set();
        let p = root
        while (stack.length || p){
            /*用来控制访问左边*/
            while (p){
                stack.push(p)
                p = p.left;
            }
            /*
            * 到达最下边的左节点以后
            * */
            let node = stack[stack.length - 1];
            // 如果右孩子存在，且右孩子未被访问
            if (node.right && !visited.has(node.right)){
                p = node.right;
                visited.add(node.right)
            }else {
                arr.push(node.val)
                stack.pop()
            }
        }
        return arr
    }

    /*
    * 二叉树的层序遍历
    * 利用队列的方式
    * */
    function levelOrder (root) {
        if(!root) return [];
        let queue = [];
        let res = [];
        let level = 0;
        queue.push(root)
        while (queue.length){
            res.push([])
            let size = queue.length;// 固定一个当时的值
            while (size--){
                let font = queue.shift()
                res[level].push(font);
                if (font.left) queue.push(font.left)
                if (font.right) queue.push(font.right)
            }
            level ++
        }
        return res
    }

</script>
</html>
