<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*
    LeetCode上机器人走格子问题，只能向下或者向右
    * 1.建立状态转移方程
        f(n,m) = f(m-1,n)+f(m,n-1)
    * 2、缓存并复用结果
        这里要建立一个二维数组来存储
    * 3、按顺序小到大计算
    *   逐行逐列的进行计算

    * */
    function fn(m,n) {
        let hashMap = [[]]
        let f=(m,n)=>{
            if (m ===1 || n===1)return  1;
            if (hashMap.get(m)){
                return hashMap.get(m)
            }
            let a= fn(m-1,n)+f(m,n-1)
            hashMap[m][n].push(a)
            return a
        }

    }

    /*
    * 用一个比较特别的方法去解这道题
    * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
    * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
    * */
    function newFn(m,n) {
        /*
        * 1、定义一个二维数组我的每一行是一个数组,每一个格子的值代表当前我走到这里
        * 有多少种方法
        * */
        let count = m;
        let arr = [];
        while (count) {
            arr.push([])
            count--
        }

        /*
        * 2、求出他的状态转移方程
        * f(m,n) = f(m-1,n)+f(m,n-1)
        * */

        /*
        * 3、我们来求出他的初始值
        * 每行第一列都是1，因为只能下移动
        * 第一行都是1，因为只能右移动
        * */
        for (let i=0;i<n;i++){
            arr[0][i] =1
        }
        for (let i=0;i<m;i++){
            arr[i][0] =1
        }

        for (let i=1;i<n;i++){
            for (let j=1;j<m;j++){
                console.log(arr[i])
             arr[i][j] = arr[i-1][j] + arr[i][j-1]
            }
        }
        console.log(arr)
    }
    newFn(5,5)
</script>
</html>
